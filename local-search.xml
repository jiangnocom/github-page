<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性代数第一章注意点</title>
    <link href="/2024/12/10/24_12_10%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%B0%8F%E7%BB%93/"/>
    <url>/2024/12/10/24_12_10%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>第一章最重要的也就是行列式和克拉默法则，在做题上技巧应该不多，写此文对自己第一章的知识进行复习。</p><h1 id="线性代数第一章注意点">线性代数第一章注意点</h1><h2 id="行列式求解注意">1 行列式求解注意</h2><ul><li>计算行列式一般化成三角行列式，就可以直接求出行列式的值，通法就是将第一行第一列的值转变为1，将一列下面的值全部化为0。</li><li>注意观察和提出公因数。</li><li>范德蒙德行列式计算如下(2 3 4 5需要为等比数列)： <spanclass="math display">\[\begin{Vmatrix}1 &amp;  2 &amp;  2^{2}&amp;  2^{3}\\1 &amp;  3 &amp;  3^{2}&amp;  3^{3}\\1 &amp;  4 &amp;  4^{2}&amp;  4^{3}\\1 &amp;  5 &amp;  5^{2}&amp;  5^{3}\\\end{Vmatrix}  \\= (3-2)\times(4-3)\times(4-2)\times(5-4)\times(5-3)\times(5-2)  \\= 12\]</span> 其实就是大的减小的然后全部相乘。</li></ul><h2 id="展开定理注意">2 展开定理注意</h2><ul><li>注意按行展开为那一行的值乘上对应的<strong>代数余子式！</strong></li><li>若给出如<spanclass="math inline">\(A_{31}-5A_{32}+3A_{33}\)</span>的关于代数余子式的式子，先寻找行列式中有没有对应的行，若没有则可以将代数余子式对应的行改为其给出的系数来求值。<strong>注意：系数可以为零！！</strong></li><li>若用展开定理来求行列式，尽量使对应的行产生尽可能多的<spanclass="math inline">\(0\)</span></li></ul><h2 id="克拉默法则注意">3 克拉默法则注意</h2><ul><li><strong>应用条件</strong>：方程组个数=未知数个数</li><li>只能用于齐次方程组判断唯一解或非零解？</li></ul><p>第一章目前就这么多注意点。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32F407时钟系统解析</title>
    <link href="/2024/11/29/24_11_29_STM32F407Clock/"/>
    <url>/2024/11/29/24_11_29_STM32F407Clock/</url>
    
    <content type="html"><![CDATA[<h1 id="stm32f407时钟系统框图">1. STM32F407时钟系统框图</h1><p><imgsrc="https://s3.bmp.ovh/imgs/2024/11/29/f791f9f512843529.webp" /></p><p>时钟作为一个单片机的脉搏，有必要好好了解一下。</p><h2 id="为什么时钟需要被分为许多频率">1.1为什么时钟需要被分为许多频率？</h2><p>在传统51单片机中，一般只有一个时钟频率，而stm32有多个分频有以下原因：- 减小功耗 - 为了增强抗干扰能力 - 为了给不同外设提供时钟</p><h2 id="f407的时钟来源">1.2 F407的时钟来源</h2><ul><li>LS IRC：低速内部时钟(32Khz 内部RC震荡产生可提供给：看门狗、RTC)</li><li>LSE DSC：低速外部时钟（32.768KHz可提供给：RTC）</li><li>HSI RC：高速内部时钟 （16MHz内部RC产生可提供给：系统时钟、PLL）</li><li>PLLCLK：锁相环时钟输出，分为PLL（可提供给：系统、USBOTG）与PLLI2S（可提供给：I2S（音质需求））</li><li>HSE OSC：高速外部时钟（4-26Mhz 外接晶振可提供给：RTC、输出引脚（PA8（MCO1）,PC9（MCO2）））</li></ul><p><strong>提供给PLLCLK的时钟可能来源如下：</strong> - HSI - HSE</p><p><strong>提供给系统的时钟可能来源如下：</strong> - HSI - HSE -PLLCLK</p><p><strong>MCO1的可能来源</strong> - HIS - LSE - HSE - PLL</p><p><strong>MCO2的可能来源</strong> - HSE - PLL - SYSCLK - PLLI2S</p><p><strong>如何计算PLLCLK：</strong></p><p>无论HSI或HSE作为PLLCLK时钟来源，都首先经过/M的分频 如图然后经过xN、/p输出PLLCLK即如下公式（<spanclass="math inline">\(f\)</span>为HSI或HSE输入）:</p><p><span class="math display">\[ PLLCLK = \frac{f}{M} \times \frac{N}{P}\]</span></p><p>若使用8Mhz外部时钟则系统运行频率：</p><p><span class="math display">\[ PLLCLK = \frac{8Mhz}{8} \times\frac{336}{2} = 168(Mhz) \]</span></p><h2 id="系统时钟的去向">1.3系统时钟的去向</h2><p>SYSCLOCK去向： - 以太网RTP时钟 - AHBPRESC -APBPRESC(APB1、APB2)在AHB分频之后</p><h1id="f4固件库中systeminit时钟系统初始化函数">2.F4固件库中SystemInit()时钟系统初始化函数</h1><p>调用时机：在系统复位之后，在执行main函数之前。</p><p>基本为RCC寄存器的配置，如：使能时钟源、读取就绪状态、重置寄存器、关闭所有系统中断、启动CSS时钟安全寄存器。</p><h2 id="初始化之后的状态">2.1 初始化之后的状态</h2><ul><li>SYSCLOCK:168Mhz</li><li>AHB:168Mhz</li><li>APB1:42Mhz</li><li>APB2:84Mhz</li><li>PLL:168Mhz</li></ul><p>初始化之后若需要获取系统频率，可以访问SystemCoreClock变量来得到</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>stm32</tag>
      
      <tag>时钟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录制作的一款全地形小车（暨第一次大学比赛）</title>
    <link href="/2024/11/10/24_11_10_competition/"/>
    <url>/2024/11/10/24_11_10_competition/</url>
    
    <content type="html"><![CDATA[<h1 id="1-起始"><a href="#1-起始" class="headerlink" title="1.起始"></a>1.起始</h1><p>从进入大学前，我就一直想进入实验室参加各种比赛，最终我进入了学校的电子实验室，开始了我的电子信息学习。</p><p>但是，在进入实验室不久，基本只是将51单片机学完，stm32没学完的情况下，就被实验室赋予了第一次任务，参加全地形车比赛。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/6063f02df162cc92.webp" alt="我与履带车见的第一面"></p><p>这是我与履带车见的第一面，本来以为还要很久才能用上，没想到这次就要“深入交流了”。</p><h1 id="2-构思"><a href="#2-构思" class="headerlink" title="2.构思"></a>2.构思</h1><p>既然都使用上履带车了，在硬件方面应该不需要大改了（我以为。。。）。那么接下来就考虑的是主控选型。</p><h2 id="2-1主控"><a href="#2-1主控" class="headerlink" title="2.1主控"></a>2.1主控</h2><p>我觉得如果要设计一款产品，其实团队会什么是占很大一部分，下面简介以下队员：</p><ul><li>队员1：我（会51,了解stm32,比较能动手）</li><li>队员2：只会51</li><li>队员3：只略懂stm32</li></ul><p>那么在我只会两款单片机的情况下（51与stm32）可选的情况显然不多，再加上我对stm32的理解不够深刻以及队员大部分只掌握了51单片机，所以我选择了51单片机作为主控，再加上我正好有一块寻迹小车51主板，那么主控显而易见。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/d1b92f718ed1f309.webp" alt="51主板"></p><h2 id="2-2其他硬件"><a href="#2-2其他硬件" class="headerlink" title="2.2其他硬件"></a>2.2其他硬件</h2><p>主控已经确定，那么作为一项需要循迹、爬坡和过各种障碍的全地形车，走直线以及找路就成为了本任务的重点了。</p><hr><p>在找路方面，我使用了八路灰度传感器<br><img src="https://s3.bmp.ovh/imgs/2024/11/10/8c74db7f9b89029d.webp" alt="八路灰度传感器"></p><p>足够我进行十字路口和直角转弯了。</p><hr><p>在走直线方面，我使用了mpu6050陀螺仪（偏航角）加以循迹的辅助，最终在障碍、爬坡、平地寻线和无线可循的情况下都实现了在一定误差内走直线的效果。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/5706ac7c4192fcdf.webp" alt="mpu6050"></p><p>既然都使用了陀螺仪，那么姿态解算这项任务，51单片机的性能很显然不够，此时便必然要使用stm32。</p><p>为了显示偏航角，便又加上了OLED（1306）小屏幕</p><hr><p>在电源方面，本打算使用航模电池，但是由于能找到的电池全部鼓包以及价格过高，便使用了售卖的成品电池（自带充电线，电源线，比较方便）</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/52089c1b7e98cc72.webp" alt="蓝色即为电池"></p><p>电池为12v输出，我在多次修改之后使用了3个降压模块（太多了，可以简化）分别作为：</p><ul><li>主控3.3v</li><li>电机编码器5v</li><li>电机驱动7v</li></ul><p><strong>电机驱动为7v是为了更快速的反应。</strong></p><hr><p>在机械结构方面，由于电池重量使得车辆重心偏移，车辆在上坡时会向后仰然后翻过去于是我每次都需要用手扶以下，那么我就将这项工作交给了车辆的“小尾巴”。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/70f3cb6cf7149b1c.webp" alt="尾巴"></p><p>而且车辆在不使用任何软件算法的情况下，会偏航，于是我尝试更换了车辆的履带以及编码器电机（主要是为了另一个编码器电机上的轴）来尝试改进。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/a44cbb94e8d0e8fa.webp" alt="change motor"></p><p>（好难拆，于是买了一套棘轮螺丝刀。。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/7d285a20c34a5dc3.webp"></p><hr><p>在轮子方面，我将原来缺少的减震弹簧补全，使车身过障碍时减小抖动。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/be6ccab4e304a8f5.jpg" alt="spring"></p><hr><p>在电机驱动方面，我本想使用L298N,实际上也确实使用L298N，优点如下：</p><ul><li>耐压值高</li><li>具有降压供能</li><li>使用简单</li></ul><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/c82003e8449057ea.webp" alt="L298N为红色"></p><p>但是我并未使用，反而我使用了TB6612</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/8ab1b0ca2338625a.png" alt="TB6612"></p><p>主要时体积小，也对其不太了解，想尝试一下。</p><p>最终，成功烧毁。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/fb7240f1eca826b8.webp" alt="烧毁"><br>左侧为烧毁的tb6612,由于焊死，取不下来了，所以为了防止再次需要更换，我在右侧焊接了母座来防止再次烧毁的更换。</p><hr><h2 id="2-3电气连接"><a href="#2-3电气连接" class="headerlink" title="2.3电气连接"></a>2.3电气连接</h2><p>很显然，作为一名新电子信息人，制作一块自己的pcb显然略显不成熟，于是我采用了简单粗暴的洞洞板，并进行了简单布局（实际一点都不简单），布局在后续的模块修改中更换了许多次，吸了不少铅（焊烟。。。）</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/81949802b12378a2.webp" alt="最初的布局"></p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/dac941846af27728.webp" alt="最初的布局（实际）"></p><p>于是我进行了焊接。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/10/3023ca7c55524870.webp" alt="焊接"></p><p>第一次焊洞洞板。实属难看。</p><p>多次修改后就变为如下布局及焊接。<br><img src="https://s3.bmp.ovh/imgs/2024/11/23/f3898930f559040e.webp"></p><h1 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h1><p>在比赛测试时，发现了一个致命问题，由于赛道中阶梯上表面为磨砂材质且小车履带的塑料材质以及其包裹的一层布无法提供足够的摩擦力，<br>使得无法完美的上阶梯，于是我开始对履带进行改造，使用了不同双面胶，磨砂胶带，去除履带外层，有一点效果，可是由于没有粘性足够的胶将其粘在履带上，使得履带与外层任何胶带都不同步，甚至一度卡住车轮，<br>最终在比赛前，我去除了所有胶带，但是为了提供一点摩擦力，我又贴了一些双面胶，起到了一点作用，但在开赛时，出现了另一个致命问题。</p><p>在发车时，一切顺利。但在第一个路口便出现了不对劲，小车没有循迹到第一个十字路口，导致第一个上坡就卡住。于是我拿回小车，紧急调整循迹灵敏度，最终调整完毕，但损失了太多时间。</p><p>我开始了第二次发车，开头仍较为顺利，但在上阶梯式，仍被卡住，在比赛时我没有找到原因，复盘后发现由于我在赛前对车的“小尾巴”增加了一些胶带，导致了小车在上台阶后仰时被胶带增加了过多摩擦力（此处也有可能由于履带摩擦力的原因）最终导致了以下结果</p><ul><li>小车上坡吃力</li><li>小车下坡左偏</li></ul><p>连续两次发车都遭遇此问题。</p><p>最终，我开始了第四次发车，这次运气不错，过去了阶梯，接下来本应顺利再过几个障碍，可是时间所剩为零，最终，这次比赛成为了一次，彻彻底底，善始不善终的比赛，同时也浪费了我在软件上的努力。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p>这次比赛，很显然，循迹、履带及尾部支撑都为硬件问题，足以体现我在硬件上缺少足够的考虑、足够的测试和足够的验证。<br>那么在实验室测试时没有发现这些问题的原因我总结为场地元素不够标准，本次不够标准的地方就在于忽略了阶梯上表面的材质，下次测试时需重视测试元素以及测试规范。</p><p>在比赛时，不应对车身进行大改，需要将这些问题尽量在赛前测试出来，即使需要改动也要尽量小范围修改。<br>修改完一定要进行测试再上场（这就是产生我本次循迹问题的原因）。</p><p>此次比赛时间不够也是我未完赛的原因之一，在有时间限制的比赛中，一定要注意对时间的把控，减少失误时刻。</p><p>虽然此次比赛较为失败，但是失去一些东西时，总会得到一些东西，经验是最宝贵的东西。</p><p>引用一句话：</p><p><em>人类活动具有不可预测的复杂性。在我们尝试之前，大多数手工艺看起来都很简单，但自己动手就不是一回事儿了。甚至当我们对某一行业驾轻就熟时，也总会有一些意想不到的挑战，把我们送进一个全新的试炼场。</em></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>51单片机</tag>
      
      <tag>硬件</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node编写命令行工具</title>
    <link href="/2024/11/09/24_11_9_nodeCLI/"/>
    <url>/2024/11/09/24_11_9_nodeCLI/</url>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>最近在写博客时要插入图片，受限于网站带宽，不可能使用上兆大小的图片，所以就需要一个程序来处理高质量的jpg，png图片，所以我便编写了一个命令行工具。此处记录如何创建node的命令行工具，并且直接调用。</p><p>示例：<code>hwebp -i ./yourdir</code></p><h1 id="2-创建"><a href="#2-创建" class="headerlink" title="2.创建"></a>2.创建</h1><h2 id="2-1初始化项目"><a href="#2-1初始化项目" class="headerlink" title="2.1初始化项目"></a>2.1初始化项目</h2><p>创建一个文件夹，并使用命令行工具打开（windows上）。<br><img src="https://s3.bmp.ovh/imgs/2024/11/09/ad2fb316346a637b.webp"></p><p>输入<code>npm init -y</code>来初始化</p><p>此时会创建以下项目<br><img src="https://s3.bmp.ovh/imgs/2024/11/09/8c2867ed155db42a.webp"><br>此时初始化已完成。</p><h2 id="2-2修改package-json"><a href="#2-2修改package-json" class="headerlink" title="2.2修改package.json"></a>2.2修改package.json</h2><p>点进去后发现以下内容</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;keywords&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>我们需要在文件的第一个大括号内加入以下代码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span><br>...<br><span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;hwebp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;./app.js&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>bin</code>中存放的是你的命令的名字，<code>hwebp</code>就是命令名字，<code>./app.js</code>就是要执行的文件。<br>但此时我们在命令行中输入<code>hwebp -i ./yourdir</code>仍然不行，我们需要告诉操作系统，执行这个文件的程序是什么，在node中即为node.js。</p><h2 id="2-3声明执行程序"><a href="#2-3声明执行程序" class="headerlink" title="2.3声明执行程序"></a>2.3声明执行程序</h2><p>打开app.js<br>若操作系统为windows，在app.js第一行加入<code>#!node</code><br>若操作系统为linux,在app.js第一行加入<code>#!/usr/bin/env node</code></p><h2 id="2-4npm安装自己的命令行工具"><a href="#2-4npm安装自己的命令行工具" class="headerlink" title="2.4npm安装自己的命令行工具"></a>2.4npm安装自己的命令行工具</h2><p>此时保存好自己的修改，再次打开app.js所在文件夹的命令行，输入<code>npm link</code>就可以安装自己的工具了。</p><p>接下来，随便在哪个文件夹的命令行中就可以使用自己的命令行工具了。<br><img src="https://s3.bmp.ovh/imgs/2024/11/09/7c2181b80338cedd.webp"></p>]]></content>
    
    
    <categories>
      
      <category>nodejs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记第一次打PCB（51核心板）</title>
    <link href="/2024/11/09/24_11_8_PCB/"/>
    <url>/2024/11/09/24_11_8_PCB/</url>
    
    <content type="html"><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>最近在焊洞洞板时，属实是觉得难焊，而且布局十分困难，于是便产生了学EDA的想法。</p><p>于是我忙里偷闲，迅速入门了嘉立创EDA。</p><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://s3.bmp.ovh/imgs/2024/11/09/3ef0e3adf862bf9e.webp"></p><p>其实当我开始画原理图时，发现外围电路其实芯片手册上已基本覆盖，所以并没用碰到许多困难。</p><p>所以芯片手册是非常重要的。</p><h1 id="PCB布线"><a href="#PCB布线" class="headerlink" title="PCB布线"></a>PCB布线</h1><p><img src="https://s3.bmp.ovh/imgs/2024/11/09/57d982f0318ef07d.webp"></p><p>PCB学到了这么几点</p><ul><li>走线不可出现锐角，尽量使用135°角</li><li>电源线加粗</li><li>少使用过孔</li><li>差分信号线注意等长</li><li>晶振注意不可放在板子边缘，注意包地</li><li>丝印一定要清晰！！</li></ul><p><img src="https://s3.bmp.ovh/imgs/2024/11/09/8058c02b52d5fba2.webp"></p><h1 id="实物图"><a href="#实物图" class="headerlink" title="实物图"></a>实物图</h1><p>最后放几张实物图吧，等我空了再来焊接元件（嘉立创BOM好贵。。）</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/09/2ce07c4eadcd1344.webp"></p><p><img src="https://s3.bmp.ovh/imgs/2024/11/09/17f8814569e1e339.webp"></p>]]></content>
    
    
    <categories>
      
      <category>EDA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
      <tag>PCB</tag>
      
      <tag>EDA</tag>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次51单片机外部中断问题</title>
    <link href="/2024/11/02/24_11_2_it_problem/"/>
    <url>/2024/11/02/24_11_2_it_problem/</url>
    
    <content type="html"><![CDATA[<h1 id="1-起因"><a href="#1-起因" class="headerlink" title="1.起因"></a>1.起因</h1><p>由于最近正在做全地形小车，为了获取小车的两个编码器电机速度，所以我便想到了使用51单片机的外部中断进行计数，于是我便操作寄存器开启了单片机的外部中断。  </p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Ex0_Init</span><span class="hljs-params">()</span><br>&#123;<br>IT0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//中断模式设置(1:下降沿触发， 0:低电平触发</span><br>EX0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//使能外部中断0</span><br>EA = <span class="hljs-number">1</span>; <span class="hljs-comment">//开总中断</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Ex1_Init</span><span class="hljs-params">()</span><br>&#123;<br>IT1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//中断模式设置(1:下降沿触发， 0:低电平触发</span><br>EX1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//使能外部中断1</span><br>EA = <span class="hljs-number">1</span>; <span class="hljs-comment">//开总中断</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-问题"><a href="#2-问题" class="headerlink" title="2.问题"></a>2.问题</h1><p>在我开启了两个中断之后，我给下降沿低电平测试，结果发现中断0可以正常工作，中断1死活不能正常工作。于是我尝试更换了单片机芯片，仍然无法解决问题，此时我便排除了芯片问题。那么下一步我便更换了51开发板，发现仍然无法解决问题。此时我便排除了板子的电路问题。</p><p>那么硬件问题全部排除，最终只剩下一种可能。便是软件问题。</p><h1 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h1><p>我便翻出stc89c52rc的文档，找出了中断1初始化的配置，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//External interrupt service routine</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  IT1 = <span class="hljs-number">1</span>;<br>  EX1 = <span class="hljs-number">1</span>;<br>  EA = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>寥寥几行代码，我复制粘贴然后尝试，仍然无法解决。</p><p>此时，我就排除了初始化函数的问题。</p><p>于是我将所有其他函数全部注释。只留下中断，发现能够正常运行！经过我的排查，在我的程序中开启了一个定时器，这个定时器隔一段时间就会运行，然后打断外部中断。</p><p>到此，问题就浮出水面。</p><p>我将外部中断初始化改为以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Ex0_Init</span><span class="hljs-params">()</span><br>&#123;<br>IT0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//中断模式设置(1:下降沿触发， 0:低电平触发</span><br>EX0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//使能外部中断0</span><br>EA = <span class="hljs-number">1</span>; <span class="hljs-comment">//开总中断</span><br><br><br>PX0 = <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Ex1_Init</span><span class="hljs-params">()</span><br>&#123;<br>IT1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//中断模式设置(1:下降沿触发， 0:低电平触发</span><br>EX1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//使能外部中断1</span><br>EA = <span class="hljs-number">1</span>; <span class="hljs-comment">//开总中断</span><br><br><br>PX1 = <span class="hljs-number">1</span>;        <br>&#125;<br></code></pre></td></tr></table></figure><p>代码中<code>px1 = 1;</code>与<code>px0 = 0;</code>为新增代码。</p><p>这两句代码给外部中断配置了优先级，使其不被定时器中断打扰。程序正常运行！问题解决。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h1><p><strong>在51单片机中使用多个中断时，务必考虑优先级。</strong><br><strong>在配置任何外设时，务必配置完整，使外设可控。</strong></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
      <tag>中断</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51单片机串口uart串口初步学习</title>
    <link href="/2024/09/08/24_9_8_UART/"/>
    <url>/2024/09/08/24_9_8_UART/</url>
    
    <content type="html"><![CDATA[<h1 id="51单片机串口uart串口初步学习"><a href="#51单片机串口uart串口初步学习" class="headerlink" title="51单片机串口uart串口初步学习"></a>51单片机串口uart串口初步学习</h1><h2 id="1-什么是串口"><a href="#1-什么是串口" class="headerlink" title="1.什么是串口"></a>1.什么是串口</h2><ul><li>一种应用十分广泛的通讯接口，可以使单片机与单片机，单片机与电脑或者模块之间互相通信。</li><li>UART（通用异步收发器）</li></ul><p>这是其中一种串口接口</p><p><img src="https://s3.bmp.ovh/imgs/2024/09/08/0c5baee9f0abfd36.png" alt="DB9"></p><p>但我们在笔记本上常用usb转串口（CH340）来连接uart。</p><h2 id="2-如何连接串口"><a href="#2-如何连接串口" class="headerlink" title="2.如何连接串口"></a>2.如何连接串口</h2><h3 id="2-1连接方式"><a href="#2-1连接方式" class="headerlink" title="2.1连接方式"></a>2.1连接方式</h3><pre><code class="hljs">VCC-VCCTXD-RXDRXD-TXDGND-GND</code></pre><p><strong>注意：TXD与RXD交叉连接；若单向数据传输可以只连接一根线；当电平标准不一致时，需要电平转换芯片（如RS232，RS485，TTL）</strong></p><p>以下为电平标准介绍：</p><p><img src="https://s3.bmp.ovh/imgs/2024/09/08/072c183f84a1340a.png"></p><h2 id="3-其他通信接口介绍"><a href="#3-其他通信接口介绍" class="headerlink" title="3.其他通信接口介绍"></a>3.其他通信接口介绍</h2><table><thead><tr><th align="center">名称</th><th align="center">引脚</th><th align="center">通信方式</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">uart</td><td align="center">TX,RX</td><td align="center">全双工，异步</td><td align="center">点对点</td></tr><tr><td align="center">I2C</td><td align="center">SCL,SDA</td><td align="center">全双工，同步</td><td align="center">可挂载多个设备</td></tr><tr><td align="center">SPI</td><td align="center">SCLK,MOSI,MISO,CS</td><td align="center">全双工，同步</td><td align="center">可挂载多个设备</td></tr><tr><td align="center">1—Wire</td><td align="center">DQ</td><td align="center">全双工，同步</td><td align="center">可挂载多个设备</td></tr></tbody></table><p><strong>此外还有can总线，USB等。</strong></p><h2 id="4-51单片机的UART"><a href="#4-51单片机的UART" class="headerlink" title="4. 51单片机的UART"></a>4. 51单片机的UART</h2><p> STC89C52 只有一个UART</p><p>  其工作模式有四种</p><ul><li>模式0：同步移位寄存器</li><li>模式1：8位UART，波特率可变</li><li>模式2：9位UART，波特率固定</li><li>模式3：9位UART，波特率可变</li></ul><p>常用模式为模式1。</p><p>以下为串口模式图：</p><p><img src="https://s3.bmp.ovh/imgs/2024/09/08/6bda7f58d60a3f78.png"></p><p>以下为完整模式图：</p><p><img src="https://s3.bmp.ovh/imgs/2024/09/08/1a7803435fb614b3.png"></p><p>接下来即配置寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UartInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//9600bps@11.0592MHz</span><br>&#123;<br>PCON &amp;= <span class="hljs-number">0x7F</span>;<span class="hljs-comment">//波特率不倍速</span><br>SCON = <span class="hljs-number">0x50</span>;<span class="hljs-comment">//8位数据,可变波特率</span><br>AUXR &amp;= <span class="hljs-number">0xBF</span>;<span class="hljs-comment">//定时器1时钟为Fosc/12,即12T</span><br>AUXR &amp;= <span class="hljs-number">0xFE</span>;<span class="hljs-comment">//串口1选择定时器1为波特率发生器</span><br>TMOD &amp;= <span class="hljs-number">0x0F</span>;<span class="hljs-comment">//清除定时器1模式位</span><br>TMOD |= <span class="hljs-number">0x20</span>;<span class="hljs-comment">//设定定时器1为8位自动重装方式</span><br>TL1 = <span class="hljs-number">0xFD</span>;<span class="hljs-comment">//设定定时初值</span><br>TH1 = <span class="hljs-number">0xFD</span>;<span class="hljs-comment">//设定定时器重装值</span><br>ET1 = <span class="hljs-number">0</span>;<span class="hljs-comment">//禁止定时器1中断</span><br>TR1 = <span class="hljs-number">1</span>;<span class="hljs-comment">//启动定时器1</span><br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">UART_SendByte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Byte)</span><br>&#123;<br>SBUF = Byte;<br><span class="hljs-keyword">while</span> (TI == <span class="hljs-number">0</span>)<br>;<br>TI = <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="附：波特率如何计算？"><a href="#附：波特率如何计算？" class="headerlink" title="附：波特率如何计算？"></a>附：波特率如何计算？</h2><p>若给计时器配置为0xF3(243),即每计13个数溢出一次。</p><p>又当使用12Mhz的晶振，在12T模式下，每一微秒记一次数。</p><p>所以，每隔13us溢出一次，溢出的频率即为1&#x2F;13（0.0769230769230769）MHz</p><p>若波特率加倍 就是（0.07692&#x2F;16）MHz &#x3D; 0.00480769MHz &#x3D; 4807.69Hz(约等于4800Hz)，有略微误差。若为11.0582Mhz晶振，可以没有误差。</p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
      <tag>串口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51单片机定时器初步学习</title>
    <link href="/2024/09/03/24_9_3_timer/"/>
    <url>/2024/09/03/24_9_3_timer/</url>
    
    <content type="html"><![CDATA[<h1 id="51单片机定时器"><a href="#51单片机定时器" class="headerlink" title="51单片机定时器"></a>51单片机定时器</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>  定时器属于内部资源，其电路与运转都在单片机内部。（也是一种计数器）</p><h3 id="1-2定时器作用"><a href="#1-2定时器作用" class="headerlink" title="1.2定时器作用"></a>1.2定时器作用</h3><ul><li>用于计时系统，软件计时，以及隔一段时间完成一项操作。</li><li>替代长时间的Delay。</li><li>多个任务同时执行，提高CPU的运行效率和处理速度。</li></ul><h2 id="2-STC89C52的定时器资源"><a href="#2-STC89C52的定时器资源" class="headerlink" title="2.STC89C52的定时器资源"></a>2.STC89C52的定时器资源</h2><ul><li>数量：3个（其他定时器不一定为此数量）</li></ul><h2 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h2><p>根据时钟信号，经过一段时间来对寄存器操作（加一），我们通过中断来设定何时进行什么任务。</p><h2 id="4-定时器的工作模式"><a href="#4-定时器的工作模式" class="headerlink" title="4.定时器的工作模式"></a>4.定时器的工作模式</h2><ul><li>模式0：13位定时器&#x2F;计数器（少用）</li><li>模式1：16位定时器&#x2F;计数器（常用）</li><li>模式2：8位自动重装模式（少用）</li><li>模式3：两个8位计数器</li></ul><p><strong>以下只讲解模式1</strong></p><p>定时器分为3个部分：</p><ul><li>时钟</li><li>计数器</li><li>中断</li></ul><h3 id="4-1如何计数？"><a href="#4-1如何计数？" class="headerlink" title="4.1如何计数？"></a>4.1如何计数？</h3><p>模式一中计数器由两个8位寄存器组成（最大数即为65535），时钟信号每一个脉冲加1，当加到65535（准确说是65536）时溢出，变为0（此时将申请中断）。</p><h3 id="4-2时钟"><a href="#4-2时钟" class="headerlink" title="4.2时钟"></a>4.2时钟</h3><p>本开发板的晶振为11.0592MHz，但是时钟信号可以由外部引脚（如T0），此时可以作为计数器（一个脉冲+1），若由芯片内部时钟，此时即为计数器。</p><p>时钟信号进入单片机之后，会进行分频（除以12或是除以6？，如果是12Mhz除以12，那么一个周期就是1us）</p><h3 id="4-3中断系统"><a href="#4-3中断系统" class="headerlink" title="4.3中断系统"></a>4.3中断系统</h3><ul><li>中断系统是为cpu具有紧急事件的实时处理能力而设置的。</li><li>当cpu在执行任务时有紧急任务需要处理时，cpu可以暂停转而去处理这个紧急事件，然后再返回到原来被中断的地方，这就是中断系统。</li><li>cpu可以有多个中断源，我们可以为不同中断源设置优先级，cpu总是会首先处理优先级最高的任务（若已经在优先级较低的中断处理中，会停止处理，转而优先级高的中断源（即中断嵌套）。）</li></ul><h4 id="中断系统的资源"><a href="#中断系统的资源" class="headerlink" title="中断系统的资源"></a>中断系统的资源</h4><p>不同系统具有不同的中断资源如：中断源个数不同、中断源优先级不同等。</p><p>89C52单片机中断资源如下：</p><ul><li>中断源个数：8个</li><li>中断优先级个数：4个</li><li>中断号如下表<table><thead><tr><th align="center">序号</th><th>中断源</th></tr></thead><tbody><tr><td align="center">0</td><td>外部中断0</td></tr><tr><td align="center">1</td><td>定时器0</td></tr><tr><td align="center">2</td><td>外部中断1</td></tr><tr><td align="center">3</td><td>定时器1</td></tr><tr><td align="center">4</td><td>串口中断</td></tr><tr><td align="center">5</td><td>定时器2</td></tr><tr><td align="center">6</td><td>外部中断2</td></tr><tr><td align="center">7</td><td>外部中断3</td></tr></tbody></table></li></ul><p>中断函数写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Int0_Routine</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> interrupt 0;<br></code></pre></td></tr></table></figure><p>中断优先级，查看手册，或者以此图为参考（51单片机向下兼容，此图也计时器与中断系统的结合）</p><p><img src="https://s3.bmp.ovh/imgs/2024/09/03/025f4f5d25e7b445.png"></p><h2 id="5-配置"><a href="#5-配置" class="headerlink" title="5.配置"></a>5.配置</h2><p>了解完基本原理，剩下的即为配置寄存器。<br>此图为定时器的寄存器<br><img src="https://s3.bmp.ovh/imgs/2024/09/03/e6d8a2becf9799c8.png"></p>]]></content>
    
    
    <categories>
      
      <category>单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
      <tag>定时器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针初步学习</title>
    <link href="/2024/08/25/note/"/>
    <url>/2024/08/25/note/</url>
    
    <content type="html"><![CDATA[<h1 id="指针初步学习"><a href="#指针初步学习" class="headerlink" title="指针初步学习"></a>指针初步学习</h1><h2 id="1-指针是什么？"><a href="#1-指针是什么？" class="headerlink" title="1.指针是什么？"></a>1.指针是什么？</h2><p>电脑内存这么大我们怎么管理？<br>于是我们创造了指针。</p><ul><li>指针是内存最小单位的一个地址</li></ul><p>假设以下一格为一个字节（Byte）<br>类比为房间，如何才能找到每个房间，于是就进行编号。</p><table><thead><tr><th align="right">编号</th><th align="center">内存单元</th></tr></thead><tbody><tr><td align="right">1</td><td align="center"></td></tr><tr><td align="right">2</td><td align="center"></td></tr><tr><td align="right">3</td><td align="center"></td></tr><tr><td align="right">…</td><td align="center">…</td></tr></tbody></table><p>这个编号为内存地址，即为指针。</p><p>假设我们要对<code>int a</code>取地址，<code>int</code>大小为4个字节，C语言就会取出第一个字节的地址。</p><p>如：</p><table><thead><tr><th align="right">编号(本质为二进制但是用16进制展示)</th><th align="center">内存单元</th></tr></thead><tbody><tr><td align="right">0x00dbfd98</td><td align="center">a</td></tr><tr><td align="right">0x00dbfd99</td><td align="center">a</td></tr><tr><td align="right">0x00dbfd9a</td><td align="center">a</td></tr><tr><td align="right">0x00dbfd9b</td><td align="center">a</td></tr></tbody></table><p>此处<code>&amp;a = 0x00dbfd98</code>。</p><p><strong>但是注意</strong>：我们在口头中所说指针一般为C语言的指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* pa = &amp;a;<br><span class="hljs-comment">//一般我们在这里就把pa这个指针变量说成指针</span><br><span class="hljs-comment">//本文中我会区分指针与指针变量。</span><br></code></pre></td></tr></table></figure><p>在不同的机器上，指针长度不同，32位即32bit，能管理4GB的内存（二进制：11111111 11111111 11111111 11111111），所以在32位机器上一个指针变量大小为4字节。</p><h2 id="2-指针和指针类型"><a href="#2-指针和指针类型" class="headerlink" title="2.指针和指针类型"></a>2.指针和指针类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>*   pc = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">short</span>*  ps = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span>*    pi = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">double</span>* pd = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>这些不同类型的指针变量在32位下都是4个字节,<br>那么为什么要区分这些不同类型的指针呢？</p><h3 id="2-1指针类型的意义"><a href="#2-1指针类型的意义" class="headerlink" title="2.1指针类型的意义"></a>2.1指针类型的意义</h3><p><strong>举例1：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a = <span class="hljs-number">0x11223344</span>;<br><span class="hljs-type">char</span>* pc = (<span class="hljs-type">char</span>*)&amp;a;<br>*pc = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>此时a被修改为了0x11223300。  </p><p>所以指针类型决定了指针在被解引用时访问几个字节，如果是<code>char*</code>在解引用是访问1个字节，导致了例子中的情况。</p><p><strong>举例2：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>   a = <span class="hljs-number">0x11223344</span>;<br><br><span class="hljs-type">char</span>* pc = (<span class="hljs-type">char</span>*)&amp;a;<br><span class="hljs-type">int</span>*  pi = &amp;a;<br><br>pc+<span class="hljs-number">1</span>;<span class="hljs-comment">//这里加1会给地址加1个字节</span><br>pi+<span class="hljs-number">1</span>;<span class="hljs-comment">//这里加1会给地址加4个字节</span><br></code></pre></td></tr></table></figure><p>即根据指针变量类型的不同进行地址的操作。</p><p>那么<code>int*</code>与<code>float*</code>可以通用吗？<br>显然不可以，在解引用时对于内存的操作仍是不同的。</p><h2 id="3-野指针"><a href="#3-野指针" class="headerlink" title="3.野指针"></a>3.野指针</h2><h3 id="3-1什么是野指针？"><a href="#3-1什么是野指针？" class="headerlink" title="3.1什么是野指针？"></a>3.1什么是野指针？</h3><p><strong>定义：指针指向的位置是不可知的。</strong></p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p ;<br>*p = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>此处p没有初始化，意味着没有明确的指向（即不初始化放的是随机值）这里的p就是野指针。</p><p>此外还有：  </p><ul><li>指针越界访问（如访问超出数组长度的地址）</li><li>指针指向的空间释放（如函数返回一个指针后被销毁）</li></ul><h3 id="3-2如何避免野指针的出现。"><a href="#3-2如何避免野指针的出现。" class="headerlink" title="3.2如何避免野指针的出现。"></a>3.2如何避免野指针的出现。</h3><ul><li>对指针明确初始化（或初始化为<code>NULL</code>，但此时无法解引用）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//以下为一种安全的初始化方式：</span><br><span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (p3 != <span class="hljs-literal">NULL</span>)<br>&#123;<br>    *p3 = <span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>避免越界</li><li>避免局部变量的指针</li><li>使用前检查指针的有效性</li></ul><h2 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h2><h3 id="4-1指针-整数"><a href="#4-1指针-整数" class="headerlink" title="4.1指针+-整数"></a>4.1指针+-整数</h3><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_VALUES 5</span><br><span class="hljs-type">float</span> values[N_VALUES];<br><span class="hljs-type">float</span> *vp;<br><span class="hljs-keyword">for</span>(vp = &amp;values[<span class="hljs-number">0</span>]; vp &lt; &amp;values[N_VALUES];)<br>&#123;<br>    *vp++;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：此处<code>*vp++</code>拆分为<code>*vp;</code>和<code>vp++;</code></p><h3 id="4-2指针-指针"><a href="#4-2指针-指针" class="headerlink" title="4.2指针-指针"></a>4.2指针-指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,&amp;arr[<span class="hljs-number">9</span>] - &amp;arr[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">//结果为9</span><br></code></pre></td></tr></table></figure><p>指针减去指针得到的是指针之间元素的个数。但不是所有的指针都能相减，只有指向同一块空间的指针才能相减，才有意义。</p><h4 id="4-2-1用法"><a href="#4-2-1用法" class="headerlink" title="4.2.1用法"></a>4.2.1用法</h4><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">my_strlen</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span><br>&#123;<br>    <span class="hljs-type">char</span>* start = str;<br>    <span class="hljs-keyword">while</span> (*str != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        str++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (str - start);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> len = my_strlen(<span class="hljs-string">&quot;abcdef&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,len);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是有没有指针+指针呢？<br>有，但是无意义。类比于生活中的日期加日期，无意义。</p><h3 id="4-3指针的关系运算"><a href="#4-3指针的关系运算" class="headerlink" title="4.3指针的关系运算"></a>4.3指针的关系运算</h3><ul><li>其实就是比较大小</li></ul><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N_VALUES 5</span><br><span class="hljs-type">float</span> values[N_VALUES];<br><span class="hljs-type">float</span> *vp;<br><span class="hljs-keyword">for</span>(vp = &amp;values[N_VALUES<span class="hljs-number">-1</span>]; vp &gt;= &amp;values[<span class="hljs-number">0</span>];vp--)<br>&#123;<br>    *vp = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可以通过编译，但是标准不规定其可行，因为<code>N_VALUES-1</code>访问了数组前的内存是不推荐的（但是可以访问数组后，即数组越界只允许往后越界）。</p><h2 id="5-指针与数组"><a href="#5-指针与数组" class="headerlink" title="5.指针与数组"></a>5.指针与数组</h2><ul><li>数组是一组相同类型元素的集合</li><li>指针变量是一个变量，存放的是地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>* p =arr;<br>    <span class="hljs-comment">//p为首元素地址</span><br>    <span class="hljs-comment">//联系就是数组名</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好久不见。</title>
    <link href="/2024/08/23/hello-world/"/>
    <url>/2024/08/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s3.bmp.ovh/imgs/2023/01/28/f910bfe1af04d2a8.jpg" alt="星空"></p><h2 id="好久不见！"><a href="#好久不见！" class="headerlink" title="好久不见！"></a>好久不见！</h2><p>回顾一下我的博客历史：</p><h3 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h3><p>自第一次创建“博客”来，已过去了4年，至今还记得亲手写下第一个html标签时的心潮澎湃。  </p><p>但我不满足于区区html，便又在网上寻觅，便遇见了wordpress，第一次搭建了php环境，被其强大的交互能力折服，那时还不知道什么前端后端，只知道，wordpress好强大。  </p><p>没有公网主机的我用一台笔记本内网穿透，域名解析，强制让它7x24小时运行（哈哈</p><p>最终还是抵不过运维的压力（滑稽，其实是懒得搞了</p><h3 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h3><p>小屁孩终究还是敌不过想要一个自己的网站的欲望，却又想白嫖。我便去找能够使用的免费的服务器（小水管）<br>部署了typecho（简洁好用）。但是，白嫖的总是不稳定，没多久便又挂了。</p><h3 id="现阶段"><a href="#现阶段" class="headerlink" title="现阶段"></a>现阶段</h3><p>现在，我部署了hexo生成静态页面上传至GitHub，作为我第三阶段（或许是最终阶段）博客的开始，同时也是人生的一个新阶段，我想我会尽力记录我的学习经验，毕竟，再怎么漂亮的博客页面，比不上丰硕的博客内容。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
